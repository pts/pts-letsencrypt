#! /bin/sh
# by pts@fazekas.hu at Mon Apr 11 20:50:45 CEST 2016

""":" #pts-letsencrypt: Convenient script for manual letsencrypt on Unix.

type python2.7 >/dev/null 2>&1 && exec python2.7 -- "$0" ${1+"$@"}
type python2.6 >/dev/null 2>&1 && exec python2.6 -- "$0" ${1+"$@"}
type python2.5 >/dev/null 2>&1 && exec python2.5 -- "$0" ${1+"$@"}
type python2.4 >/dev/null 2>&1 && exec python2.4 -- "$0" ${1+"$@"}
exec python -- ${1+"$@"}; exit 1

This script needs Python 2.4 .. 2.7 to run. It doesn't work with Python 3.x.
It has been tested with Python 2.7.

This script is written carefully so that porting to Windows becomes possible
in the future.
"""

# TODO(pts): What are the problems of letsencrypt as is? running as root; writing in too many dirs; trying to edit webserver configs; is interactive by default; has too many library dependencies; needs too many flags to specify for renewal, too confusing, other side: same cert for multiple domains
# TODO(pts): Set umask, chmod certs vs chmod webroot dir. Protect everything (even after renew), but let the (non-root?) webserver access the live cert.
# TODO(pts): Does ngingx has to be reloaded to use the new cert?
# TODO(pts): Add docs to the docstring, print the docstring for --help.
# TODO(pts): Remove more unused plugins and stuff from site-packages, especially the standalone plugin and everything not needed.
# TODO(pts): !! Don't renew if it's too early to renew (such as --keep, but certonly seems to ignore it, is _should_, why config.renew_by_default is True?). (Maybe not with --staging.)
#   2016-04-12 15:45:34,857:INFO:letsencrypt.cli:Cert not yet due for renewal
# TODO(pts): If supporting multiple domains, consider the --expand flag.
# TODO(pts): Add command processing for `revoke'.


def setup_path():
  import os  
  import sys
  prog = sys.argv[0]
  try:
    prog = os.readlink(prog)
  except OSError:
    pass
  assert os.path.isfile(prog)
  prog_dir = os.path.dirname(prog)
  prog_dir = os.path.abspath(prog_dir)
  if sys.path and sys.path[0] == prog_dir:
    del sys.path[0]
  sys.path[:0] = [os.path.join(prog_dir, 'lib'),
                  os.path.join(prog_dir, 'site-packages')]


def try_import_cli():
  import sys
  try:
    import letsencrypt.cli
  except ImportError:
    print >>sys.stderr, (
        'fatal: error importing letsencrypt.cli -- '
        'see message below and install dependencies')
    raise
  return letsencrypt.cli.main


def patch_non_standard_path_warning():
  """Omit displaying this warning (at least doc):

  WARNING:letsencrypt.client:Non-standard path(s), might not work with crontab installed by your operating system package manager
  """
  import letsencrypt.client
  old_warning = letsencrypt.client.logger.warning
  def new_warning(msg, *args):  # TODO(pts): Can we avoid the circular ref?
    if not str(msg).startswith('Non-standard path'):
      old_warning(msg, *args)
  letsencrypt.client.logger.warning = new_warning


def run_cli_main(cli_main, cli_args):
  import sys
  old_excepthook = sys.excepthook
  sys.argv[0] = 'letsencrypt'
  try:
    return cli_main(cli_args=cli_args)
  finally:
    sys.excepthook = old_excepthook


def usage():
  import sys
  return (
      'Usage:\n'
      '%(argv0)s --config-dir=... --domains=... --email=... [...]\n'
      '  To create a certificate. It will create the config-dir.\n'
      '  Useful flag for testing: --staging.\n'
      '%(argv0)s --config-dir=...\n'
      '  To renew a certificate. It remembers the flags at creation time.\n'
      '%(argv0)s --help all\n'
      '  To get the help of the letsencrypt tool.\n'
      '%(argv0)s [--<flag>=<value> ...] <command> [...]\n'
      '  To run the letsencrypt tool.\n' %
      {'argv0': sys.argv[0]})


def mkdir_if_missing(dirname):
  import os
  try:
    os.mkdir(dirname)
  except OSError:
    if not os.path.isdir(dirname):
      raise


def rmdir_if_exists(filename):
  import os
  try:
    os.rmdir(filename)
  except OSError:
    if os.path.exists(filename):
      raise


def remove_if_exists(filename):
  import os
  try:
    os.remove(filename)
  except OSError:
    if os.path.exists(filename):
      raise


def remove_recursively(pathname):
  import os
  if os.path.isdir(pathname):
    for dirpath, dirnames, filenames in os.walk(pathname, False):
      for filename in filenames:
        remove_if_exists(os.path.join(dirpath, filename))
      rmdir_if_exists(dirpath)
  else:
    remove_if_exists(pathname)


def http_download(host, suburl):
  import httplib
  import socket
  try:
    # Doesn't follow redirects. Good.
    conn = httplib.HTTPConnection(host, timeout=10)
    conn.request('GET', suburl)
    r1 = conn.getresponse()
    reason = 'OK'
    if r1.status != 200:
      reason = r1.reason
    return (r1.status, reason, r1.read())
  except (IOError, OSError, socket.error, socket.timeout), e:
    return (-1, '%s.%s' % (e.__class__.__module__, e.__class__.__name__),
            str(e))
  except:
    e = sys.exc_info()[1]
    return (-2, '%s.%s' % (e.__class__.__module__, e.__class__.__name__),
            str(e))


def format_flags(flags):
  args = []
  for key, value in sorted(flags.iteritems()):
    if key == 'v':
      assert isinstance(value, int)
      assert value >= 0
      for _ in xrange(value):
        args.append('-v')
    elif key == 'help':
      continue  # Will be added below.
    elif value is False:
      pass
    elif value is True:
      args.append('--%s' % key)
    else:
      args.append('--%s=%s' % (key, value))
  if flags.get('help'):  # Make it the last one for `--help all'.
    args.append('--help')
  return args


def process_flag(flags, arg):
  arg = arg.lstrip('-')
  j = arg.find('=')
  if j < 0:
    if arg in ('v', 'verbose'):
      flags['v'] = flags.get('v', 0) + 1
      return
    elif arg and not arg.rstrip('v'):  # E.g. '-vvv'.
      flags['v'] = flags.get('v', 0) + len(arg)
      return
    key, value = arg, True
  else:
    key, value = arg[:j], arg[j + 1:]
    if key == 'authenticator':
      flags[value] = True  # E.g. 'webroot', 'standalone'.
  flags[key] = value


def main(args=None):
  import os
  import sys
  import traceback

  if args is None:
    args = sys.argv[1:]
  default_flags = {
    'rsa-key-size': 4096,
    # Default.
    #'server': 'https://acme-v01.api.letsencrypt.org/directory',
    'text': True,
    'noninteractive': True,
    'agree-tos': True,
    #'staging': True,  # Enable this for testing.
    # (under .well-known/acme-challenge/)
  }
  flags = {}
  if args == ['--help']:
    sys.stdout.write(usage())
    sys.exit(0)
  
  cmdargs = []
  i = 0
  while i < len(args):
    arg = args[i]
    i += 1
    if arg == '--':
      cmdargs.extend(args[i:])
      break
    if arg.startswith('-') and arg != '-':
      process_flag(flags, arg)
    else:
      cmdargs.append(arg)
      cmdargs.extend(args[i:])
      break
  dir_arg = flags.get('config-dir')

  if cmdargs == [] and flags.get('help') is None:
    if not dir_arg:
      print >>sys.stderr, 'fatal: Missing flag --config-dir=...'
      sys.exit(1)
    for key in ('renew', 'apache', 'nginx', 'manual'):
      if key in flags:
        print >>sys.stderr, 'fatal: Please do not specify --%s' % key
        sys.exit(1)
    for key in ('config', 'webroot-path'):
      if key in flags:
        print >>sys.stderr, 'fatal: Please do not specify --%s=...' % key
        sys.exit(1)
    if flags.get('standalone') and flags.get('webroot'):
      print >>sys.stderr, (
          'fatal: Please specify at most one of --standalone and --webroot')
      sys.exit(1)
    is_standalone = bool(flags.get('standalone'))
    flags.pop('standalone', None)
    flags.pop('webroot', None)

    flags2 = dict(flags)
    flags2.pop('config-dir', None)
    flags2.pop('renew', None)
    flags2.pop('v', None)
    flags2.pop('keep-until-expiring', None)
    flags2.pop('keep', None)
    flags2.pop('reinstall', None)
    flags2.pop('force-renewal', None)
    flags2.pop('renew-by-default', None)
    flags2.pop('autenticator', None)

    args2 = format_flags(flags2)
    config_data = ''.join(arg + '\n' for arg in args2)
    config_fn = os.path.join(dir_arg, 'pts-letsencrypt.flags')
    if os.path.exists(config_fn):
      f = open(config_fn)
      rargs = []
      try:
        for line in f:
          line = line.rstrip('\r\n')
          if line and not line.startswith('#'):
            rargs.append(line)
            if not flags2:
              process_flag(flags, line)
      finally:
        f.close()
      rargs.sort()
      # TODO(pts): Allow overwrite if no csr yet (e.g. after a failed httplib).
      if args2 and rargs != args2:
        print >>sys.stderr, (
            'fatal: Command-line flags (%r) do not match flags in '
            'config file %s (%r).' %
            (args2, config_fn, rargs))
        print >>sys.stderr, (
            'fatal: For certificate renewal, just specify --config-dir=...')
        sys.exit(1)
    else:
      mkdir_if_missing(dir_arg)
      f = open(config_fn, 'w')
      try:
        f.write(config_data)
      finally:
        f.close()

    for key, value in default_flags.iteritems():
      flags.setdefault(key, value)
    if not flags.get('email'):
      print >>sys.stderr, 'fatal: Missing flag --email=...'
      sys.exit(1)
    domains_arg = flags.get('domains', '')
    if ''.join(domains_arg.split()) != domains_arg:
      print >>sys.stderr, 'fatal: Whitespace in --domains=...'
      sys.exit(1)
    domains = filter(None, domains_arg.split(','))
    if not domains:
      print >>sys.stderr, 'fatal: Missing flag --domains=...'
      sys.exit(1)
    if len(domains) > 1:
      print >>sys.stderr, 'fatal: Currently unsupported comma in --domains=...'
      sys.exit(1)
    flags['domains'] = ','.join(domains)

    # (under .well-known/acme-challenge/)
    if is_standalone:
      flags['standalone'] = True  # Equivalent: --authenticator=webroot
    else:
      flags['webroot'] = True  # Equivalent: --authenticator=standalone
      flags['webroot-path'] = os.path.join(dir_arg, 'webroot')
    mkdir_if_missing(dir_arg)
    mkdir_if_missing(os.path.join(dir_arg, 'webroot'))
    mkdir_if_missing(os.path.join(dir_arg, 'webroot', '.well-known'))
    mkdir_if_missing(os.path.join(dir_arg, 'webroot', '.well-known',
                                  'acme-challenge'))
    mkdir_if_missing(os.path.join(dir_arg, 'work'))
    mkdir_if_missing(os.path.join(dir_arg, 'log'))

    plefn = os.path.join(dir_arg, 'webroot', '.well-known',
                         'acme-challenge', 'plemark.txt')
    import random
    import time
    # Doesn't matter much, doesn't have to be secure.
    pledata = '%08x' % (int(time.time()) & 0xffffffff) + ''.join(
        '%02x' % random.randrange(256) for i in xrange(30)) + '\n'
    try:
      f = open(plefn, 'w')
      try:
        f.write(pledata)
      finally:
        f.close()
      suburl = '/.well-known/acme-challenge/plemark.txt'
      url = 'http://%s%s' % (domains[0], suburl)
      expected_http_result = (200, 'OK', pledata)
      if is_standalone:
        import socket
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        try:
          # letsencrypt.plugins.standalone also binds to this address.
          bind_address = ('', 80)
          try:
            sock.bind(bind_address)
          except socket.error, e:
            # TODO(pts): Port this to Windows.
            err_msg = str(e).lower()
            if 'permission' in err_msg:
              print >>sys.stderr, (
                  'fatal: Unable to bind to port 80, you probably need root '
                  'permissions for that. You may rerun with sudo, but for '
                  'better security, please use the default --webroot instead '
                  'of --standalone')
              sys.exit(4)
            if 'address already in use' in err_msg:
              # letsencrypt returns the program name and process ID here.
              # TODO(pts): Reuse that code and display it as well.
              print >>sys.stderr, (
                  'fatal: Another program is listening on port 80, please '
                  'stop it temporarily, rerun, and start it again. But please '
                  'consider the default --webroot instead '
                  'of --standalone')
              sys.exit(4)
            print >>sys.stderr, (
                'fatal: Binding to port 80 failed: %s' % e)
            sys.exit(4)
        finally:
          sock.close()
      else:
        http_result = http_download(domains[0], suburl)
        if http_result != expected_http_result:
          http_result = (http_result[0], http_result[1], http_result[2][:128])
          print >>sys.stderr, (
              'error: Got from webserver for %s: %r\n'
              '       Expected: %r' %
              (url, http_result, expected_http_result))
          print >>sys.stderr, (
              'fatal: Please set up your webserver on localhost so that '
              '%s/ serves %s/ , and rerun this command.' %
              (url[:url.rfind('/')], os.path.abspath(os.path.dirname(plefn))))
          sys.exit(2)

      flags.setdefault('logs-dir', os.path.join(dir_arg, 'log'))
      flags.setdefault('work-dir', os.path.join(dir_arg, 'work'))
      # Not needed: flags['config'] = ...
      if os.path.exists(os.path.join(dir_arg, 'csr')):
        # Directory 'csr' was created when the certificate was first created.
        # So we want to renew.
        flags['renew'] = True
      cli_args = format_flags(flags)
      cli_args.append('certonly')
      purpose = ('creation', 'renewal')[bool(flags.get('renew'))]
      print >>sys.stderr, 'info: Running letsencrypt for %s with args: %r' % (
          purpose, cli_args)
      try:
        cli_error = run_cli_main(cli_main, cli_args)
      except SystemExit, e:
        cli_error = e[0]
      except:
        cli_error = sys.exc_info()[:2]
        if flags.get('v') > 0:
          traceback.print_exc()
      # TODO(pts): Remove the custom error handler set up by run_cli_main.
      if cli_error:
        if not flags.get('renew'):
          for subdir in ('renewal', 'keys', 'csr', 'archive', 'accounts',
                         'live'):
            remove_recursively(os.path.join(dir_arg, subdir))
        print >>sys.stderr, 'error: Error running letsencrypt: %s' % (cli_error,)
        sys.exit(3)
      print >>sys.stderr, 'info: Certificate %s OK.' % purpose
    finally:
      # Keep plefn until this so that cli_main doesn't try to remove the
      # acme-challenge dir.
      remove_if_exists(plefn)
    # The `IMPORTANT NOTES:' will be printed after this, in the exit hook.
    # If the certificate is not due for renewal, no notes are printed.
    # TODO(pts): Always print an info message if it was not due.
  else:
    if dir_arg is not None:
      flags.setdefault('logs-dir', os.path.join(dir_arg, 'log'))
      flags.setdefault('work-dir', os.path.join(dir_arg, 'work'))
    cli_args = format_flags(flags)
    if cmdargs and cmdargs[0] == 'help':  # Workaround.
      cmdargs[0] = '--help'
    cli_args.extend(cmdargs)
    sys.exit(run_cli_main(cli_main, cli_args))


if __name__ == '__main__':
  setup_path()
  cli_main = try_import_cli()
  patch_non_standard_path_warning()
  main()
